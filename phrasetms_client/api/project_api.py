# coding: utf-8

"""
    Phrase TMS API

    Welcome to Phrase's TMS API documentation.    Please visit our [help center](https://support.phrase.com/hc/en-us/sections/5709662083612) for more information about the APIs.    If you have any questions, please contact [Support](https://support.phrase.com/hc/requests/new).    Please, include the `User-Agent` header with the name of your application or project. It might be a good idea to include some sort of contact information as well, so that we can get in touch if necessary. Examples of excellent `User-Agent` headers:  > User-Agent: Example mobile app (example@phrase.com) <br/> User-Agent: ACME Inc Java 1.8 Client (http://acmeinc.com/contact)  # noqa: E501

    OpenAPI spec version: Latest
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from phrasetms_client.models import (
    FileNamingSettingsDto,
    ProjectTransMemoryListDtoV3,
    ProjectTermBaseListDto,
    QASettingsDtoV2,
    MTSettingsPerLanguageListDto,
    FinancialSettingsDto,
    SearchResponseListTmDto,
    PageDtoTransMemoryDto,
    PageDtoTermBaseDto,
    AbstractProjectDto,
    ProviderListDtoV2,
    PageDtoAbstractProjectDto,
    PageDtoAnalyseReference,
    PageDtoProjectReference,
    PageDtoQuoteDto,
    ProjectWorkflowStepListDtoV2,
    LqaSettingsDto,
    PageDtoProviderReference,
    ProjectSecuritySettingsDtoV2,
    PreTranslateSettingsV3Dto,
    FileImportSettingsDto,
    PageDtoCustomFieldInstanceDto,
    CustomFieldInstanceDto,
    AnalyseSettingsDto,
    EnabledQualityChecksDto,
    AbstractProjectDtoV2,
    CustomFieldInstancesDto,
    AsyncRequestWrapperV2Dto,
    AssignableTemplatesDto,
    JobPartsDto,
)
from phrasetms_client.api_client import ApiClient


class ProjectApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_target_language_to_project(
        self, project_uid, **kwargs
    ) -> None:  # noqa: E501
        """Add target languages  # noqa: E501

        Add target languages to project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_target_language_to_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param AddTargetLangDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.add_target_language_to_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.add_target_language_to_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def add_target_language_to_project_with_http_info(
        self, project_uid, **kwargs
    ) -> None:  # noqa: E501
        """Add target languages  # noqa: E501

        Add target languages to project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_target_language_to_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param AddTargetLangDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_target_language_to_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `add_target_language_to_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/targetLangs",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def add_workflow_steps(self, project_uid, **kwargs) -> None:  # noqa: E501
        """Add workflow steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_workflow_steps(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param AddWorkflowStepsDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.add_workflow_steps_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.add_workflow_steps_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def add_workflow_steps_with_http_info(
        self, project_uid, **kwargs
    ) -> None:  # noqa: E501
        """Add workflow steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_workflow_steps_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param AddWorkflowStepsDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_workflow_steps" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `add_workflow_steps`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/workflowSteps",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def assign_linguists_from_template(
        self, template_uid, project_uid, **kwargs
    ) -> JobPartsDto:  # noqa: E501
        """Assigns providers from template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_linguists_from_template(template_uid, project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_uid: (required)
        :param str project_uid: (required)
        :return: JobPartsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.assign_linguists_from_template_with_http_info(
                template_uid, project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.assign_linguists_from_template_with_http_info(
                template_uid, project_uid, **kwargs
            )  # noqa: E501
            return data

    def assign_linguists_from_template_with_http_info(
        self, template_uid, project_uid, **kwargs
    ) -> JobPartsDto:  # noqa: E501
        """Assigns providers from template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_linguists_from_template_with_http_info(template_uid, project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_uid: (required)
        :param str project_uid: (required)
        :return: JobPartsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["template_uid", "project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_linguists_from_template" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'template_uid' is set
        if "template_uid" not in params or params["template_uid"] is None:
            raise ValueError(
                "Missing the required parameter `template_uid` when calling `assign_linguists_from_template`"
            )  # noqa: E501
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `assign_linguists_from_template`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "template_uid" in params:
            path_params["templateUid"] = params["template_uid"]  # noqa: E501
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/applyTemplate/{templateUid}/assignProviders",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="JobPartsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def assign_linguists_from_template_to_job_parts(
        self, template_uid, project_uid, **kwargs
    ) -> JobPartsDto:  # noqa: E501
        """Assigns providers from template (specific jobs)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_linguists_from_template_to_job_parts(template_uid, project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_uid: (required)
        :param str project_uid: (required)
        :param JobPartReferences body:
        :return: JobPartsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.assign_linguists_from_template_to_job_parts_with_http_info(
                template_uid, project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.assign_linguists_from_template_to_job_parts_with_http_info(
                template_uid, project_uid, **kwargs
            )  # noqa: E501
            return data

    def assign_linguists_from_template_to_job_parts_with_http_info(
        self, template_uid, project_uid, **kwargs
    ) -> JobPartsDto:  # noqa: E501
        """Assigns providers from template (specific jobs)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_linguists_from_template_to_job_parts_with_http_info(template_uid, project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_uid: (required)
        :param str project_uid: (required)
        :param JobPartReferences body:
        :return: JobPartsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["template_uid", "project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_linguists_from_template_to_job_parts" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'template_uid' is set
        if "template_uid" not in params or params["template_uid"] is None:
            raise ValueError(
                "Missing the required parameter `template_uid` when calling `assign_linguists_from_template_to_job_parts`"
            )  # noqa: E501
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `assign_linguists_from_template_to_job_parts`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "template_uid" in params:
            path_params["templateUid"] = params["template_uid"]  # noqa: E501
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/applyTemplate/{templateUid}/assignProviders/forJobParts",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="JobPartsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def assign_vendor_to_project(self, project_uid, **kwargs) -> None:  # noqa: E501
        """Assign vendor  # noqa: E501

         To unassign Vendor from Project, use empty body: ``` {} ```       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_vendor_to_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param AssignVendorDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.assign_vendor_to_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.assign_vendor_to_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def assign_vendor_to_project_with_http_info(
        self, project_uid, **kwargs
    ) -> None:  # noqa: E501
        """Assign vendor  # noqa: E501

         To unassign Vendor from Project, use empty body: ``` {} ```       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_vendor_to_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param AssignVendorDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_vendor_to_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `assign_vendor_to_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/assignVendor",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def assignable_templates(
        self, project_uid, **kwargs
    ) -> AssignableTemplatesDto:  # noqa: E501
        """List assignable templates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assignable_templates(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: AssignableTemplatesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.assignable_templates_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.assignable_templates_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def assignable_templates_with_http_info(
        self, project_uid, **kwargs
    ) -> AssignableTemplatesDto:  # noqa: E501
        """List assignable templates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assignable_templates_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: AssignableTemplatesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assignable_templates" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `assignable_templates`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/assignableTemplates",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AssignableTemplatesDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def clone_project(self, project_uid, **kwargs) -> AbstractProjectDto:  # noqa: E501
        """Clone project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param CloneProjectDto body:
        :return: AbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.clone_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.clone_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def clone_project_with_http_info(
        self, project_uid, **kwargs
    ) -> AbstractProjectDto:  # noqa: E501
        """Clone project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param CloneProjectDto body:
        :return: AbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clone_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `clone_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/clone",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AbstractProjectDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def create_custom_fields(
        self, project_uid, **kwargs
    ) -> CustomFieldInstancesDto:  # noqa: E501
        """Create custom field instances  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_custom_fields(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param CreateCustomFieldInstancesDto body:
        :return: CustomFieldInstancesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.create_custom_fields_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.create_custom_fields_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def create_custom_fields_with_http_info(
        self, project_uid, **kwargs
    ) -> CustomFieldInstancesDto:  # noqa: E501
        """Create custom field instances  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_custom_fields_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param CreateCustomFieldInstancesDto body:
        :return: CustomFieldInstancesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_custom_fields" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `create_custom_fields`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["*/*"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/customFields",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CustomFieldInstancesDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def create_project_from_template_v2(
        self, template_uid, **kwargs
    ) -> AbstractProjectDtoV2:  # noqa: E501
        """Create project from template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_from_template_v2(template_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_uid: (required)
        :param CreateProjectFromTemplateV2Dto body:
        :return: AbstractProjectDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.create_project_from_template_v2_with_http_info(
                template_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.create_project_from_template_v2_with_http_info(
                template_uid, **kwargs
            )  # noqa: E501
            return data

    def create_project_from_template_v2_with_http_info(
        self, template_uid, **kwargs
    ) -> AbstractProjectDtoV2:  # noqa: E501
        """Create project from template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_from_template_v2_with_http_info(template_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_uid: (required)
        :param CreateProjectFromTemplateV2Dto body:
        :return: AbstractProjectDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["template_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_from_template_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'template_uid' is set
        if "template_uid" not in params or params["template_uid"] is None:
            raise ValueError(
                "Missing the required parameter `template_uid` when calling `create_project_from_template_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "template_uid" in params:
            path_params["templateUid"] = params["template_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/projects/applyTemplate/{templateUid}",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AbstractProjectDtoV2",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def create_project_from_template_v2_async(
        self, template_uid, **kwargs
    ) -> AsyncRequestWrapperV2Dto:  # noqa: E501
        """Create project from template (async)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_from_template_v2_async(template_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_uid: (required)
        :param CreateProjectFromTemplateAsyncV2Dto body:
        :return: AsyncRequestWrapperV2Dto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.create_project_from_template_v2_async_with_http_info(
                template_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.create_project_from_template_v2_async_with_http_info(
                template_uid, **kwargs
            )  # noqa: E501
            return data

    def create_project_from_template_v2_async_with_http_info(
        self, template_uid, **kwargs
    ) -> AsyncRequestWrapperV2Dto:  # noqa: E501
        """Create project from template (async)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_from_template_v2_async_with_http_info(template_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_uid: (required)
        :param CreateProjectFromTemplateAsyncV2Dto body:
        :return: AsyncRequestWrapperV2Dto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["template_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_from_template_v2_async" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'template_uid' is set
        if "template_uid" not in params or params["template_uid"] is None:
            raise ValueError(
                "Missing the required parameter `template_uid` when calling `create_project_from_template_v2_async`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "template_uid" in params:
            path_params["templateUid"] = params["template_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/projects/applyTemplate/async/{templateUid}",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AsyncRequestWrapperV2Dto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def create_project_v3(self, **kwargs) -> AbstractProjectDtoV2:  # noqa: E501
        """Create project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_v3(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateProjectV3Dto body:
        :return: AbstractProjectDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.create_project_v3_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_project_v3_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_project_v3_with_http_info(
        self, **kwargs
    ) -> AbstractProjectDtoV2:  # noqa: E501
        """Create project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_v3_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateProjectV3Dto body:
        :return: AbstractProjectDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_v3" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projects",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AbstractProjectDtoV2",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_custom_field1(
        self, project_uid, field_instance_uid, **kwargs
    ) -> None:  # noqa: E501
        """Delete custom field of project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_custom_field1(project_uid, field_instance_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str field_instance_uid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_custom_field1_with_http_info(
                project_uid, field_instance_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_custom_field1_with_http_info(
                project_uid, field_instance_uid, **kwargs
            )  # noqa: E501
            return data

    def delete_custom_field1_with_http_info(
        self, project_uid, field_instance_uid, **kwargs
    ) -> None:  # noqa: E501
        """Delete custom field of project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_custom_field1_with_http_info(project_uid, field_instance_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str field_instance_uid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "field_instance_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_custom_field1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `delete_custom_field1`"
            )  # noqa: E501
        # verify the required parameter 'field_instance_uid' is set
        if "field_instance_uid" not in params or params["field_instance_uid"] is None:
            raise ValueError(
                "Missing the required parameter `field_instance_uid` when calling `delete_custom_field1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501
        if "field_instance_uid" in params:
            path_params["fieldInstanceUid"] = params["field_instance_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/customFields/{fieldInstanceUid}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_project(self, project_uid, **kwargs) -> None:  # noqa: E501
        """Delete project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param bool purge:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def delete_project_with_http_info(
        self, project_uid, **kwargs
    ) -> None:  # noqa: E501
        """Delete project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param bool purge:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "purge"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `delete_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "purge" in params:
            query_params.append(("purge", params["purge"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def edit_custom_field(
        self, project_uid, field_instance_uid, **kwargs
    ) -> CustomFieldInstanceDto:  # noqa: E501
        """Edit custom field of project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_custom_field(project_uid, field_instance_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str field_instance_uid: (required)
        :param UpdateCustomFieldInstanceDto body:
        :return: CustomFieldInstanceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.edit_custom_field_with_http_info(
                project_uid, field_instance_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.edit_custom_field_with_http_info(
                project_uid, field_instance_uid, **kwargs
            )  # noqa: E501
            return data

    def edit_custom_field_with_http_info(
        self, project_uid, field_instance_uid, **kwargs
    ) -> CustomFieldInstanceDto:  # noqa: E501
        """Edit custom field of project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_custom_field_with_http_info(project_uid, field_instance_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str field_instance_uid: (required)
        :param UpdateCustomFieldInstanceDto body:
        :return: CustomFieldInstanceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "field_instance_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_custom_field" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `edit_custom_field`"
            )  # noqa: E501
        # verify the required parameter 'field_instance_uid' is set
        if "field_instance_uid" not in params or params["field_instance_uid"] is None:
            raise ValueError(
                "Missing the required parameter `field_instance_uid` when calling `edit_custom_field`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501
        if "field_instance_uid" in params:
            path_params["fieldInstanceUid"] = params["field_instance_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["*/*"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/customFields/{fieldInstanceUid}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CustomFieldInstanceDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def edit_custom_fields(
        self, project_uid, **kwargs
    ) -> CustomFieldInstancesDto:  # noqa: E501
        """Edit custom fields of the project (batch)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_custom_fields(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param UpdateCustomFieldInstancesDto body:
        :return: CustomFieldInstancesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.edit_custom_fields_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.edit_custom_fields_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def edit_custom_fields_with_http_info(
        self, project_uid, **kwargs
    ) -> CustomFieldInstancesDto:  # noqa: E501
        """Edit custom fields of the project (batch)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_custom_fields_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param UpdateCustomFieldInstancesDto body:
        :return: CustomFieldInstancesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_custom_fields" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `edit_custom_fields`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["*/*"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/customFields",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CustomFieldInstancesDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def edit_import_settings1(
        self, project_uid, **kwargs
    ) -> FileImportSettingsDto:  # noqa: E501
        """Edit project import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_import_settings1(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param FileImportSettingsCreateDto body:
        :return: FileImportSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.edit_import_settings1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.edit_import_settings1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def edit_import_settings1_with_http_info(
        self, project_uid, **kwargs
    ) -> FileImportSettingsDto:  # noqa: E501
        """Edit project import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_import_settings1_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param FileImportSettingsCreateDto body:
        :return: FileImportSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_import_settings1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `edit_import_settings1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/importSettings",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileImportSettingsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def edit_project_access_settings_v2(
        self, project_uid, **kwargs
    ) -> ProjectSecuritySettingsDtoV2:  # noqa: E501
        """Edit access and security settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_project_access_settings_v2(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditProjectSecuritySettingsDtoV2 body:
        :return: ProjectSecuritySettingsDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.edit_project_access_settings_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.edit_project_access_settings_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def edit_project_access_settings_v2_with_http_info(
        self, project_uid, **kwargs
    ) -> ProjectSecuritySettingsDtoV2:  # noqa: E501
        """Edit access and security settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_project_access_settings_v2_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditProjectSecuritySettingsDtoV2 body:
        :return: ProjectSecuritySettingsDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_project_access_settings_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `edit_project_access_settings_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/projects/{projectUid}/accessSettings",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectSecuritySettingsDtoV2",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def edit_project_pre_translate_settings2(
        self, project_uid, **kwargs
    ) -> PreTranslateSettingsV3Dto:  # noqa: E501
        """Update Pre-translate settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_project_pre_translate_settings2(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param PreTranslateSettingsV3Dto body:
        :return: PreTranslateSettingsV3Dto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.edit_project_pre_translate_settings2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.edit_project_pre_translate_settings2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def edit_project_pre_translate_settings2_with_http_info(
        self, project_uid, **kwargs
    ) -> PreTranslateSettingsV3Dto:  # noqa: E501
        """Update Pre-translate settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_project_pre_translate_settings2_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param PreTranslateSettingsV3Dto body:
        :return: PreTranslateSettingsV3Dto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_project_pre_translate_settings2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `edit_project_pre_translate_settings2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projects/{projectUid}/preTranslateSettings",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PreTranslateSettingsV3Dto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def edit_project_v2(
        self, project_uid, **kwargs
    ) -> AbstractProjectDtoV2:  # noqa: E501
        """Edit project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_project_v2(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditProjectV2Dto body:
        :return: AbstractProjectDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.edit_project_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.edit_project_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def edit_project_v2_with_http_info(
        self, project_uid, **kwargs
    ) -> AbstractProjectDtoV2:  # noqa: E501
        """Edit project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_project_v2_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditProjectV2Dto body:
        :return: AbstractProjectDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_project_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `edit_project_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["*/*"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/projects/{projectUid}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AbstractProjectDtoV2",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def enabled_quality_checks(
        self, project_uid, **kwargs
    ) -> EnabledQualityChecksDto:  # noqa: E501
        """Get QA checks  # noqa: E501

        Returns enabled quality assurance settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enabled_quality_checks(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: EnabledQualityChecksDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.enabled_quality_checks_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.enabled_quality_checks_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def enabled_quality_checks_with_http_info(
        self, project_uid, **kwargs
    ) -> EnabledQualityChecksDto:  # noqa: E501
        """Get QA checks  # noqa: E501

        Returns enabled quality assurance settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enabled_quality_checks_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: EnabledQualityChecksDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enabled_quality_checks" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `enabled_quality_checks`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/qaSettingsChecks",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="EnabledQualityChecksDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_analyse_settings_for_project(
        self, project_uid, **kwargs
    ) -> AnalyseSettingsDto:  # noqa: E501
        """Get analyse settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_analyse_settings_for_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: AnalyseSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_analyse_settings_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_analyse_settings_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_analyse_settings_for_project_with_http_info(
        self, project_uid, **kwargs
    ) -> AnalyseSettingsDto:  # noqa: E501
        """Get analyse settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_analyse_settings_for_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: AnalyseSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_analyse_settings_for_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_analyse_settings_for_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/analyseSettings",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AnalyseSettingsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_custom_field1(
        self, project_uid, field_instance_uid, **kwargs
    ) -> CustomFieldInstanceDto:  # noqa: E501
        """Get custom field of project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_field1(project_uid, field_instance_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str field_instance_uid: (required)
        :return: CustomFieldInstanceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_custom_field1_with_http_info(
                project_uid, field_instance_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_custom_field1_with_http_info(
                project_uid, field_instance_uid, **kwargs
            )  # noqa: E501
            return data

    def get_custom_field1_with_http_info(
        self, project_uid, field_instance_uid, **kwargs
    ) -> CustomFieldInstanceDto:  # noqa: E501
        """Get custom field of project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_field1_with_http_info(project_uid, field_instance_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str field_instance_uid: (required)
        :return: CustomFieldInstanceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "field_instance_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_custom_field1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_custom_field1`"
            )  # noqa: E501
        # verify the required parameter 'field_instance_uid' is set
        if "field_instance_uid" not in params or params["field_instance_uid"] is None:
            raise ValueError(
                "Missing the required parameter `field_instance_uid` when calling `get_custom_field1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501
        if "field_instance_uid" in params:
            path_params["fieldInstanceUid"] = params["field_instance_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/customFields/{fieldInstanceUid}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CustomFieldInstanceDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_custom_fields_page(
        self, project_uid, **kwargs
    ) -> PageDtoCustomFieldInstanceDto:  # noqa: E501
        """Get custom fields of project (page)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_fields_page(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 20
        :param list[str] created_by: Filter by webhook creators UIDs
        :param list[str] modified_by: Filter by webhook updaters UIDs
        :param str sort_field: Sort by this field
        :param str sort_trend: Sort direction
        :return: PageDtoCustomFieldInstanceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_custom_fields_page_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_custom_fields_page_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_custom_fields_page_with_http_info(
        self, project_uid, **kwargs
    ) -> PageDtoCustomFieldInstanceDto:  # noqa: E501
        """Get custom fields of project (page)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_fields_page_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 20
        :param list[str] created_by: Filter by webhook creators UIDs
        :param list[str] modified_by: Filter by webhook updaters UIDs
        :param str sort_field: Sort by this field
        :param str sort_trend: Sort direction
        :return: PageDtoCustomFieldInstanceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "project_uid",
            "page_number",
            "page_size",
            "created_by",
            "modified_by",
            "sort_field",
            "sort_trend",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_custom_fields_page" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_custom_fields_page`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501
        if "created_by" in params:
            query_params.append(("createdBy", params["created_by"]))  # noqa: E501
            collection_formats["createdBy"] = "multi"  # noqa: E501
        if "modified_by" in params:
            query_params.append(("modifiedBy", params["modified_by"]))  # noqa: E501
            collection_formats["modifiedBy"] = "multi"  # noqa: E501
        if "sort_field" in params:
            query_params.append(("sortField", params["sort_field"]))  # noqa: E501
        if "sort_trend" in params:
            query_params.append(("sortTrend", params["sort_trend"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/customFields",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoCustomFieldInstanceDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_file_naming_settings(
        self, project_uid, **kwargs
    ) -> FileNamingSettingsDto:  # noqa: E501
        """Get file naming settings for project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_naming_settings(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: FileNamingSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_file_naming_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_file_naming_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_file_naming_settings_with_http_info(
        self, project_uid, **kwargs
    ) -> FileNamingSettingsDto:  # noqa: E501
        """Get file naming settings for project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_naming_settings_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: FileNamingSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_naming_settings" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_file_naming_settings`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/fileNamingSettings",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileNamingSettingsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_financial_settings(
        self, project_uid, **kwargs
    ) -> FinancialSettingsDto:  # noqa: E501
        """Get financial settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_financial_settings(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: FinancialSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_financial_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_financial_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_financial_settings_with_http_info(
        self, project_uid, **kwargs
    ) -> FinancialSettingsDto:  # noqa: E501
        """Get financial settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_financial_settings_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: FinancialSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_financial_settings" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_financial_settings`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/financialSettings",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FinancialSettingsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_import_settings2(
        self, project_uid, **kwargs
    ) -> FileImportSettingsDto:  # noqa: E501
        """Get projects's default import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_settings2(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: FileImportSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_import_settings2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_import_settings2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_import_settings2_with_http_info(
        self, project_uid, **kwargs
    ) -> FileImportSettingsDto:  # noqa: E501
        """Get projects's default import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_settings2_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: FileImportSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_settings2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_import_settings2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/importSettings",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileImportSettingsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_mt_settings_for_project(
        self, project_uid, **kwargs
    ) -> MTSettingsPerLanguageListDto:  # noqa: E501
        """Get project machine translate settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mt_settings_for_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: MTSettingsPerLanguageListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_mt_settings_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_mt_settings_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_mt_settings_for_project_with_http_info(
        self, project_uid, **kwargs
    ) -> MTSettingsPerLanguageListDto:  # noqa: E501
        """Get project machine translate settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mt_settings_for_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: MTSettingsPerLanguageListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mt_settings_for_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_mt_settings_for_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/mtSettings",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="MTSettingsPerLanguageListDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_pre_translate_settings_for_project2(
        self, project_uid, **kwargs
    ) -> PreTranslateSettingsV3Dto:  # noqa: E501
        """Get Pre-translate settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_translate_settings_for_project2(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: PreTranslateSettingsV3Dto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_pre_translate_settings_for_project2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_pre_translate_settings_for_project2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_pre_translate_settings_for_project2_with_http_info(
        self, project_uid, **kwargs
    ) -> PreTranslateSettingsV3Dto:  # noqa: E501
        """Get Pre-translate settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_translate_settings_for_project2_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: PreTranslateSettingsV3Dto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_translate_settings_for_project2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_pre_translate_settings_for_project2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projects/{projectUid}/preTranslateSettings",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PreTranslateSettingsV3Dto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_project(self, project_uid, **kwargs) -> AbstractProjectDto:  # noqa: E501
        """Get project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: AbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_project_with_http_info(project_uid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_project_with_http_info(
        self, project_uid, **kwargs
    ) -> AbstractProjectDto:  # noqa: E501
        """Get project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: AbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AbstractProjectDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_project_access_settings_v2(
        self, project_uid, **kwargs
    ) -> ProjectSecuritySettingsDtoV2:  # noqa: E501
        """Get access and security settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_access_settings_v2(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: ProjectSecuritySettingsDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_project_access_settings_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_project_access_settings_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_project_access_settings_v2_with_http_info(
        self, project_uid, **kwargs
    ) -> ProjectSecuritySettingsDtoV2:  # noqa: E501
        """Get access and security settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_access_settings_v2_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: ProjectSecuritySettingsDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_access_settings_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_project_access_settings_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/projects/{projectUid}/accessSettings",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectSecuritySettingsDtoV2",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_project_assignments(
        self, project_uid, **kwargs
    ) -> PageDtoProviderReference:  # noqa: E501
        """List project providers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_assignments(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str provider_name:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoProviderReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_project_assignments_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_project_assignments_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_project_assignments_with_http_info(
        self, project_uid, **kwargs
    ) -> PageDtoProviderReference:  # noqa: E501
        """List project providers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_assignments_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str provider_name:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoProviderReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "project_uid",
            "provider_name",
            "page_number",
            "page_size",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_assignments" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_project_assignments`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "provider_name" in params:
            query_params.append(("providerName", params["provider_name"]))  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/providers",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoProviderReference",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_project_settings(
        self, project_uid, **kwargs
    ) -> LqaSettingsDto:  # noqa: E501
        """Get LQA settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_settings(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param int workflow_level:
        :return: LqaSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_project_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_project_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_project_settings_with_http_info(
        self, project_uid, **kwargs
    ) -> LqaSettingsDto:  # noqa: E501
        """Get LQA settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_settings_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param int workflow_level:
        :return: LqaSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "workflow_level"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_settings" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_project_settings`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "workflow_level" in params:
            query_params.append(
                ("workflowLevel", params["workflow_level"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/lqaSettings",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="LqaSettingsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_project_term_bases(
        self, project_uid, **kwargs
    ) -> ProjectTermBaseListDto:  # noqa: E501
        """Get term bases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_term_bases(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: ProjectTermBaseListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_project_term_bases_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_project_term_bases_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_project_term_bases_with_http_info(
        self, project_uid, **kwargs
    ) -> ProjectTermBaseListDto:  # noqa: E501
        """Get term bases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_term_bases_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: ProjectTermBaseListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_term_bases" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_project_term_bases`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/termBases",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectTermBaseListDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_project_trans_memories1(
        self, project_uid, **kwargs
    ) -> ProjectTransMemoryListDtoV3:  # noqa: E501
        """Get translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_trans_memories1(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str target_lang: Filter project translation memories by target language
        :param str wf_step_uid: Filter project translation memories by workflow step
        :return: ProjectTransMemoryListDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_project_trans_memories1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_project_trans_memories1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_project_trans_memories1_with_http_info(
        self, project_uid, **kwargs
    ) -> ProjectTransMemoryListDtoV3:  # noqa: E501
        """Get translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_trans_memories1_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str target_lang: Filter project translation memories by target language
        :param str wf_step_uid: Filter project translation memories by workflow step
        :return: ProjectTransMemoryListDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "target_lang", "wf_step_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_trans_memories1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_project_trans_memories1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "target_lang" in params:
            query_params.append(("targetLang", params["target_lang"]))  # noqa: E501
        if "wf_step_uid" in params:
            query_params.append(("wfStepUid", params["wf_step_uid"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projects/{projectUid}/transMemories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectTransMemoryListDtoV3",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_project_workflow_steps_v2(
        self, project_uid, **kwargs
    ) -> ProjectWorkflowStepListDtoV2:  # noqa: E501
        """Get workflow steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_workflow_steps_v2(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param bool with_assigned_jobs: Return only steps containing jobs assigned to the calling linguist.
        :return: ProjectWorkflowStepListDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_project_workflow_steps_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_project_workflow_steps_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_project_workflow_steps_v2_with_http_info(
        self, project_uid, **kwargs
    ) -> ProjectWorkflowStepListDtoV2:  # noqa: E501
        """Get workflow steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_workflow_steps_v2_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param bool with_assigned_jobs: Return only steps containing jobs assigned to the calling linguist.
        :return: ProjectWorkflowStepListDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "with_assigned_jobs"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_workflow_steps_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_project_workflow_steps_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "with_assigned_jobs" in params:
            query_params.append(
                ("withAssignedJobs", params["with_assigned_jobs"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/projects/{projectUid}/workflowSteps",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectWorkflowStepListDtoV2",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_quotes_for_project(
        self, project_uid, **kwargs
    ) -> PageDtoQuoteDto:  # noqa: E501
        """List quotes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_quotes_for_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param int page_number:
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoQuoteDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_quotes_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_quotes_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def get_quotes_for_project_with_http_info(
        self, project_uid, **kwargs
    ) -> PageDtoQuoteDto:  # noqa: E501
        """List quotes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_quotes_for_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param int page_number:
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoQuoteDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "page_number", "page_size"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quotes_for_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_quotes_for_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/quotes",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoQuoteDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def list_assigned_projects(
        self, user_uid, **kwargs
    ) -> PageDtoProjectReference:  # noqa: E501
        """List assigned projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_assigned_projects(user_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_uid: (required)
        :param list[str] status:
        :param list[str] target_lang:
        :param int workflow_step_id:
        :param int due_in_hours: -1 for jobs that are overdue
        :param str filename:
        :param str project_name:
        :param int page_number:
        :param int page_size:
        :return: PageDtoProjectReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.list_assigned_projects_with_http_info(
                user_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.list_assigned_projects_with_http_info(
                user_uid, **kwargs
            )  # noqa: E501
            return data

    def list_assigned_projects_with_http_info(
        self, user_uid, **kwargs
    ) -> PageDtoProjectReference:  # noqa: E501
        """List assigned projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_assigned_projects_with_http_info(user_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_uid: (required)
        :param list[str] status:
        :param list[str] target_lang:
        :param int workflow_step_id:
        :param int due_in_hours: -1 for jobs that are overdue
        :param str filename:
        :param str project_name:
        :param int page_number:
        :param int page_size:
        :return: PageDtoProjectReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "user_uid",
            "status",
            "target_lang",
            "workflow_step_id",
            "due_in_hours",
            "filename",
            "project_name",
            "page_number",
            "page_size",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_assigned_projects" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'user_uid' is set
        if "user_uid" not in params or params["user_uid"] is None:
            raise ValueError(
                "Missing the required parameter `user_uid` when calling `list_assigned_projects`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "user_uid" in params:
            path_params["userUid"] = params["user_uid"]  # noqa: E501

        query_params = []
        if "status" in params:
            query_params.append(("status", params["status"]))  # noqa: E501
            collection_formats["status"] = "multi"  # noqa: E501
        if "target_lang" in params:
            query_params.append(("targetLang", params["target_lang"]))  # noqa: E501
            collection_formats["targetLang"] = "multi"  # noqa: E501
        if "workflow_step_id" in params:
            query_params.append(
                ("workflowStepId", params["workflow_step_id"])
            )  # noqa: E501
        if "due_in_hours" in params:
            query_params.append(("dueInHours", params["due_in_hours"]))  # noqa: E501
        if "filename" in params:
            query_params.append(("filename", params["filename"]))  # noqa: E501
        if "project_name" in params:
            query_params.append(("projectName", params["project_name"]))  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/users/{userUid}/projects",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoProjectReference",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def list_by_project_v3(
        self, project_uid, **kwargs
    ) -> PageDtoAnalyseReference:  # noqa: E501
        """List analyses by project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_by_project_v3(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str name: Name to search by
        :param str uid: Uid to search by
        :param int page_number:
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :param str sort: Sorting field
        :param str order: Sorting order
        :param bool only_owner_org:
        :return: PageDtoAnalyseReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.list_by_project_v3_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.list_by_project_v3_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def list_by_project_v3_with_http_info(
        self, project_uid, **kwargs
    ) -> PageDtoAnalyseReference:  # noqa: E501
        """List analyses by project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_by_project_v3_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str name: Name to search by
        :param str uid: Uid to search by
        :param int page_number:
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :param str sort: Sorting field
        :param str order: Sorting order
        :param bool only_owner_org:
        :return: PageDtoAnalyseReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "project_uid",
            "name",
            "uid",
            "page_number",
            "page_size",
            "sort",
            "order",
            "only_owner_org",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_by_project_v3" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `list_by_project_v3`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "uid" in params:
            query_params.append(("uid", params["uid"]))  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501
        if "sort" in params:
            query_params.append(("sort", params["sort"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "only_owner_org" in params:
            query_params.append(
                ("onlyOwnerOrg", params["only_owner_org"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projects/{projectUid}/analyses",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoAnalyseReference",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def list_projects(self, **kwargs) -> PageDtoAbstractProjectDto:  # noqa: E501
        """List projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name:
        :param int client_id:
        :param str client_name:
        :param int business_unit_id:
        :param str business_unit_name:
        :param list[str] statuses:
        :param list[str] target_langs:
        :param int domain_id:
        :param str domain_name:
        :param int sub_domain_id:
        :param str sub_domain_name:
        :param int cost_center_id:
        :param str cost_center_name:
        :param int due_in_hours: -1 for projects that are overdue
        :param int created_in_last_hours:
        :param list[str] source_langs:
        :param int owner_id:
        :param list[str] job_statuses: Allowed for linguists only
        :param str job_status_group: Allowed for linguists only
        :param int buyer_id:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :param str name_or_internal_id: Name or internal ID of project
        :param bool include_archived: List also archived projects
        :param bool archived_only: List only archived projects, regardless of `includeArchived`
        :return: PageDtoAbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.list_projects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_projects_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_projects_with_http_info(
        self, **kwargs
    ) -> PageDtoAbstractProjectDto:  # noqa: E501
        """List projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name:
        :param int client_id:
        :param str client_name:
        :param int business_unit_id:
        :param str business_unit_name:
        :param list[str] statuses:
        :param list[str] target_langs:
        :param int domain_id:
        :param str domain_name:
        :param int sub_domain_id:
        :param str sub_domain_name:
        :param int cost_center_id:
        :param str cost_center_name:
        :param int due_in_hours: -1 for projects that are overdue
        :param int created_in_last_hours:
        :param list[str] source_langs:
        :param int owner_id:
        :param list[str] job_statuses: Allowed for linguists only
        :param str job_status_group: Allowed for linguists only
        :param int buyer_id:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :param str name_or_internal_id: Name or internal ID of project
        :param bool include_archived: List also archived projects
        :param bool archived_only: List only archived projects, regardless of `includeArchived`
        :return: PageDtoAbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "name",
            "client_id",
            "client_name",
            "business_unit_id",
            "business_unit_name",
            "statuses",
            "target_langs",
            "domain_id",
            "domain_name",
            "sub_domain_id",
            "sub_domain_name",
            "cost_center_id",
            "cost_center_name",
            "due_in_hours",
            "created_in_last_hours",
            "source_langs",
            "owner_id",
            "job_statuses",
            "job_status_group",
            "buyer_id",
            "page_number",
            "page_size",
            "name_or_internal_id",
            "include_archived",
            "archived_only",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_projects" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "client_id" in params:
            query_params.append(("clientId", params["client_id"]))  # noqa: E501
        if "client_name" in params:
            query_params.append(("clientName", params["client_name"]))  # noqa: E501
        if "business_unit_id" in params:
            query_params.append(
                ("businessUnitId", params["business_unit_id"])
            )  # noqa: E501
        if "business_unit_name" in params:
            query_params.append(
                ("businessUnitName", params["business_unit_name"])
            )  # noqa: E501
        if "statuses" in params:
            query_params.append(("statuses", params["statuses"]))  # noqa: E501
            collection_formats["statuses"] = "multi"  # noqa: E501
        if "target_langs" in params:
            query_params.append(("targetLangs", params["target_langs"]))  # noqa: E501
            collection_formats["targetLangs"] = "multi"  # noqa: E501
        if "domain_id" in params:
            query_params.append(("domainId", params["domain_id"]))  # noqa: E501
        if "domain_name" in params:
            query_params.append(("domainName", params["domain_name"]))  # noqa: E501
        if "sub_domain_id" in params:
            query_params.append(("subDomainId", params["sub_domain_id"]))  # noqa: E501
        if "sub_domain_name" in params:
            query_params.append(
                ("subDomainName", params["sub_domain_name"])
            )  # noqa: E501
        if "cost_center_id" in params:
            query_params.append(
                ("costCenterId", params["cost_center_id"])
            )  # noqa: E501
        if "cost_center_name" in params:
            query_params.append(
                ("costCenterName", params["cost_center_name"])
            )  # noqa: E501
        if "due_in_hours" in params:
            query_params.append(("dueInHours", params["due_in_hours"]))  # noqa: E501
        if "created_in_last_hours" in params:
            query_params.append(
                ("createdInLastHours", params["created_in_last_hours"])
            )  # noqa: E501
        if "source_langs" in params:
            query_params.append(("sourceLangs", params["source_langs"]))  # noqa: E501
            collection_formats["sourceLangs"] = "multi"  # noqa: E501
        if "owner_id" in params:
            query_params.append(("ownerId", params["owner_id"]))  # noqa: E501
        if "job_statuses" in params:
            query_params.append(("jobStatuses", params["job_statuses"]))  # noqa: E501
            collection_formats["jobStatuses"] = "multi"  # noqa: E501
        if "job_status_group" in params:
            query_params.append(
                ("jobStatusGroup", params["job_status_group"])
            )  # noqa: E501
        if "buyer_id" in params:
            query_params.append(("buyerId", params["buyer_id"]))  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501
        if "name_or_internal_id" in params:
            query_params.append(
                ("nameOrInternalId", params["name_or_internal_id"])
            )  # noqa: E501
        if "include_archived" in params:
            query_params.append(
                ("includeArchived", params["include_archived"])
            )  # noqa: E501
        if "archived_only" in params:
            query_params.append(("archivedOnly", params["archived_only"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoAbstractProjectDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def list_providers3(self, project_uid, **kwargs) -> ProviderListDtoV2:  # noqa: E501
        """Get suggested providers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_providers3(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: ProviderListDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.list_providers3_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.list_providers3_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def list_providers3_with_http_info(
        self, project_uid, **kwargs
    ) -> ProviderListDtoV2:  # noqa: E501
        """Get suggested providers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_providers3_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :return: ProviderListDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_providers3" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `list_providers3`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/projects/{projectUid}/providers/suggest",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProviderListDtoV2",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def patch_project(self, project_uid, **kwargs) -> AbstractProjectDto:  # noqa: E501
        """Edit project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param PatchProjectDto body:
        :return: AbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.patch_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.patch_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def patch_project_with_http_info(
        self, project_uid, **kwargs
    ) -> AbstractProjectDto:  # noqa: E501
        """Edit project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param PatchProjectDto body:
        :return: AbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `patch_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AbstractProjectDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def relevant_term_bases(
        self, project_uid, **kwargs
    ) -> PageDtoTermBaseDto:  # noqa: E501
        """List project relevant term bases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relevant_term_bases(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str name:
        :param str domain_name:
        :param str client_name:
        :param str sub_domain_name:
        :param list[str] target_langs:
        :param bool strict_lang_matching:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTermBaseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.relevant_term_bases_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.relevant_term_bases_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def relevant_term_bases_with_http_info(
        self, project_uid, **kwargs
    ) -> PageDtoTermBaseDto:  # noqa: E501
        """List project relevant term bases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relevant_term_bases_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str name:
        :param str domain_name:
        :param str client_name:
        :param str sub_domain_name:
        :param list[str] target_langs:
        :param bool strict_lang_matching:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTermBaseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "project_uid",
            "name",
            "domain_name",
            "client_name",
            "sub_domain_name",
            "target_langs",
            "strict_lang_matching",
            "page_number",
            "page_size",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method relevant_term_bases" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `relevant_term_bases`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "domain_name" in params:
            query_params.append(("domainName", params["domain_name"]))  # noqa: E501
        if "client_name" in params:
            query_params.append(("clientName", params["client_name"]))  # noqa: E501
        if "sub_domain_name" in params:
            query_params.append(
                ("subDomainName", params["sub_domain_name"])
            )  # noqa: E501
        if "target_langs" in params:
            query_params.append(("targetLangs", params["target_langs"]))  # noqa: E501
            collection_formats["targetLangs"] = "multi"  # noqa: E501
        if "strict_lang_matching" in params:
            query_params.append(
                ("strictLangMatching", params["strict_lang_matching"])
            )  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/termBases/relevant",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoTermBaseDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def relevant_trans_memories1(
        self, project_uid, **kwargs
    ) -> PageDtoTransMemoryDto:  # noqa: E501
        """List project relevant translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relevant_trans_memories1(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str name:
        :param str domain_name:
        :param str client_name:
        :param str sub_domain_name:
        :param list[str] target_langs:
        :param bool strict_lang_matching:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.relevant_trans_memories1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.relevant_trans_memories1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def relevant_trans_memories1_with_http_info(
        self, project_uid, **kwargs
    ) -> PageDtoTransMemoryDto:  # noqa: E501
        """List project relevant translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relevant_trans_memories1_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str name:
        :param str domain_name:
        :param str client_name:
        :param str sub_domain_name:
        :param list[str] target_langs:
        :param bool strict_lang_matching:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "project_uid",
            "name",
            "domain_name",
            "client_name",
            "sub_domain_name",
            "target_langs",
            "strict_lang_matching",
            "page_number",
            "page_size",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method relevant_trans_memories1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `relevant_trans_memories1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "domain_name" in params:
            query_params.append(("domainName", params["domain_name"]))  # noqa: E501
        if "client_name" in params:
            query_params.append(("clientName", params["client_name"]))  # noqa: E501
        if "sub_domain_name" in params:
            query_params.append(
                ("subDomainName", params["sub_domain_name"])
            )  # noqa: E501
        if "target_langs" in params:
            query_params.append(("targetLangs", params["target_langs"]))  # noqa: E501
            collection_formats["targetLangs"] = "multi"  # noqa: E501
        if "strict_lang_matching" in params:
            query_params.append(
                ("strictLangMatching", params["strict_lang_matching"])
            )  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/transMemories/relevant",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoTransMemoryDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def search_segment1(
        self, project_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Search translation memory for segment in the project  # noqa: E501

        Returns at most <i>maxSegments</i>             records with <i>score >= scoreThreshold</i> and at most <i>maxSubsegments</i> records which are subsegment,             i.e. the source text is substring of the query text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_segment1(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SearchTMRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.search_segment1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.search_segment1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def search_segment1_with_http_info(
        self, project_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Search translation memory for segment in the project  # noqa: E501

        Returns at most <i>maxSegments</i>             records with <i>score >= scoreThreshold</i> and at most <i>maxSubsegments</i> records which are subsegment,             i.e. the source text is substring of the query text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_segment1_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SearchTMRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_segment1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `search_segment1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/transMemories/searchSegmentInProject",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SearchResponseListTmDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def set_financial_settings(
        self, project_uid, **kwargs
    ) -> FinancialSettingsDto:  # noqa: E501
        """Edit financial settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_financial_settings(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SetFinancialSettingsDto body:
        :return: FinancialSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.set_financial_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.set_financial_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def set_financial_settings_with_http_info(
        self, project_uid, **kwargs
    ) -> FinancialSettingsDto:  # noqa: E501
        """Edit financial settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_financial_settings_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SetFinancialSettingsDto body:
        :return: FinancialSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_financial_settings" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `set_financial_settings`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/financialSettings",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FinancialSettingsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def set_mt_settings_for_project(
        self, project_uid, **kwargs
    ) -> MTSettingsPerLanguageListDto:  # noqa: E501
        """Edit machine translate settings  # noqa: E501

        This will erase all mtSettings per language for project.         To remove all machine translate settings from project call without a machineTranslateSettings parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_mt_settings_for_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditProjectMTSettingsDto body:
        :return: MTSettingsPerLanguageListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.set_mt_settings_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.set_mt_settings_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def set_mt_settings_for_project_with_http_info(
        self, project_uid, **kwargs
    ) -> MTSettingsPerLanguageListDto:  # noqa: E501
        """Edit machine translate settings  # noqa: E501

        This will erase all mtSettings per language for project.         To remove all machine translate settings from project call without a machineTranslateSettings parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_mt_settings_for_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditProjectMTSettingsDto body:
        :return: MTSettingsPerLanguageListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_mt_settings_for_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `set_mt_settings_for_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/mtSettings",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="MTSettingsPerLanguageListDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def set_mt_settings_per_language_for_project(
        self, project_uid, **kwargs
    ) -> MTSettingsPerLanguageListDto:  # noqa: E501
        """Edit machine translate settings per language  # noqa: E501

        This will erase mtSettings for project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_mt_settings_per_language_for_project(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditProjectMTSettPerLangListDto body:
        :return: MTSettingsPerLanguageListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.set_mt_settings_per_language_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.set_mt_settings_per_language_for_project_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def set_mt_settings_per_language_for_project_with_http_info(
        self, project_uid, **kwargs
    ) -> MTSettingsPerLanguageListDto:  # noqa: E501
        """Edit machine translate settings per language  # noqa: E501

        This will erase mtSettings for project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_mt_settings_per_language_for_project_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditProjectMTSettPerLangListDto body:
        :return: MTSettingsPerLanguageListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_mt_settings_per_language_for_project" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `set_mt_settings_per_language_for_project`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/mtSettingsPerLanguage",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="MTSettingsPerLanguageListDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def set_project_qa_settings_v2(
        self, project_uid, **kwargs
    ) -> QASettingsDtoV2:  # noqa: E501
        """Edit quality assurance settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_qa_settings_v2(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditQASettingsDtoV2 body:
        :return: QASettingsDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.set_project_qa_settings_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.set_project_qa_settings_v2_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def set_project_qa_settings_v2_with_http_info(
        self, project_uid, **kwargs
    ) -> QASettingsDtoV2:  # noqa: E501
        """Edit quality assurance settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_qa_settings_v2_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param EditQASettingsDtoV2 body:
        :return: QASettingsDtoV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_project_qa_settings_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `set_project_qa_settings_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["*/*"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/projects/{projectUid}/qaSettings",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="QASettingsDtoV2",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def set_project_status(self, project_uid, **kwargs) -> None:  # noqa: E501
        """Edit project status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_status(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SetProjectStatusDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.set_project_status_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.set_project_status_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def set_project_status_with_http_info(
        self, project_uid, **kwargs
    ) -> None:  # noqa: E501
        """Edit project status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_status_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SetProjectStatusDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_project_status" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `set_project_status`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/setStatus",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def set_project_term_bases(
        self, project_uid, **kwargs
    ) -> ProjectTermBaseListDto:  # noqa: E501
        """Edit term bases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_term_bases(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SetTermBaseDto body:
        :return: ProjectTermBaseListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.set_project_term_bases_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.set_project_term_bases_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def set_project_term_bases_with_http_info(
        self, project_uid, **kwargs
    ) -> ProjectTermBaseListDto:  # noqa: E501
        """Edit term bases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_term_bases_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SetTermBaseDto body:
        :return: ProjectTermBaseListDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_project_term_bases" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `set_project_term_bases`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/termBases",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectTermBaseListDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def set_project_trans_memories_v3(
        self, project_uid, **kwargs
    ) -> ProjectTransMemoryListDtoV3:  # noqa: E501
        """Edit translation memories  # noqa: E501

        If user wants to edit “All target languages” or \"All workflow steps”,                         but there are already varied TM settings for individual languages or steps,                         then the user risks to overwrite these individual choices.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_trans_memories_v3(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SetProjectTransMemoriesV3Dto body:
        :return: ProjectTransMemoryListDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.set_project_trans_memories_v3_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.set_project_trans_memories_v3_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def set_project_trans_memories_v3_with_http_info(
        self, project_uid, **kwargs
    ) -> ProjectTransMemoryListDtoV3:  # noqa: E501
        """Edit translation memories  # noqa: E501

        If user wants to edit “All target languages” or \"All workflow steps”,                         but there are already varied TM settings for individual languages or steps,                         then the user risks to overwrite these individual choices.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_trans_memories_v3_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SetProjectTransMemoriesV3Dto body:
        :return: ProjectTransMemoryListDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_project_trans_memories_v3" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `set_project_trans_memories_v3`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projects/{projectUid}/transMemories",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectTransMemoryListDtoV3",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def update_file_naming_settings(
        self, project_uid, **kwargs
    ) -> FileNamingSettingsDto:  # noqa: E501
        """Update file naming settings for project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_file_naming_settings(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param FileNamingSettingsDto body:
        :return: FileNamingSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.update_file_naming_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.update_file_naming_settings_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def update_file_naming_settings_with_http_info(
        self, project_uid, **kwargs
    ) -> FileNamingSettingsDto:  # noqa: E501
        """Update file naming settings for project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_file_naming_settings_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param FileNamingSettingsDto body:
        :return: FileNamingSettingsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_file_naming_settings" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `update_file_naming_settings`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/fileNamingSettings",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="FileNamingSettingsDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
