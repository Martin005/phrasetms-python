# coding: utf-8

"""
    Phrase TMS API

    Welcome to Phrase's TMS API documentation.    Please visit our [help center](https://support.phrase.com/hc/en-us/sections/5709662083612) for more information about the APIs.    If you have any questions, please contact [Support](https://support.phrase.com/hc/requests/new).    Please, include the `User-Agent` header with the name of your application or project. It might be a good idea to include some sort of contact information as well, so that we can get in touch if necessary. Examples of excellent `User-Agent` headers:  > User-Agent: Example mobile app (example@phrase.com) <br/> User-Agent: ACME Inc Java 1.8 Client (http://acmeinc.com/contact)  # noqa: E501

    OpenAPI spec version: Latest
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from phrasetms_client.api_client import ApiClient


class TranslationMemoryApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_target_lang_to_trans_memory(
        self, trans_memory_uid, **kwargs
    ) -> TransMemoryDto:  # noqa: E501
        """Add target language to translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_target_lang_to_trans_memory(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param TargetLanguageDto body:
        :return: TransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.add_target_lang_to_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.add_target_lang_to_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def add_target_lang_to_trans_memory_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> TransMemoryDto:  # noqa: E501
        """Add target language to translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_target_lang_to_trans_memory_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param TargetLanguageDto body:
        :return: TransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_target_lang_to_trans_memory" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `add_target_lang_to_trans_memory`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/targetLanguages",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="TransMemoryDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def clear_trans_memory(self, trans_memory_uid, **kwargs) -> None:  # noqa: E501
        """Delete all segments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_trans_memory(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.clear_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.clear_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def clear_trans_memory_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> None:  # noqa: E501
        """Delete all segments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_trans_memory_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_trans_memory" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `clear_trans_memory`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/segments",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def clear_trans_memory_v2(self, trans_memory_uid, **kwargs) -> None:  # noqa: E501
        """Delete all segments.  # noqa: E501

        This call is **asynchronous**, use [this API](#operation/getAsyncRequest) to check the result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_trans_memory_v2(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.clear_trans_memory_v2_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.clear_trans_memory_v2_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def clear_trans_memory_v2_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> None:  # noqa: E501
        """Delete all segments.  # noqa: E501

        This call is **asynchronous**, use [this API](#operation/getAsyncRequest) to check the result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_trans_memory_v2_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_trans_memory_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `clear_trans_memory_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/transMemories/{transMemoryUid}/segments",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def create_trans_memory(self, **kwargs) -> TransMemoryDto:  # noqa: E501
        """Create translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_trans_memory(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransMemoryCreateDto body:
        :return: TransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.create_trans_memory_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_trans_memory_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_trans_memory_with_http_info(
        self, **kwargs
    ) -> TransMemoryDto:  # noqa: E501
        """Create translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_trans_memory_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransMemoryCreateDto body:
        :return: TransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_trans_memory" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="TransMemoryDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_source_and_translations(
        self, trans_memory_uid, segment_id, **kwargs
    ) -> None:  # noqa: E501
        """Delete both source and translation  # noqa: E501

        Not recommended for bulk removal of segments  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_source_and_translations(trans_memory_uid, segment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param str segment_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_source_and_translations_with_http_info(
                trans_memory_uid, segment_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_source_and_translations_with_http_info(
                trans_memory_uid, segment_id, **kwargs
            )  # noqa: E501
            return data

    def delete_source_and_translations_with_http_info(
        self, trans_memory_uid, segment_id, **kwargs
    ) -> None:  # noqa: E501
        """Delete both source and translation  # noqa: E501

        Not recommended for bulk removal of segments  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_source_and_translations_with_http_info(trans_memory_uid, segment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param str segment_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "segment_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_source_and_translations" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `delete_source_and_translations`"
            )  # noqa: E501
        # verify the required parameter 'segment_id' is set
        if "segment_id" not in params or params["segment_id"] is None:
            raise ValueError(
                "Missing the required parameter `segment_id` when calling `delete_source_and_translations`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501
        if "segment_id" in params:
            path_params["segmentId"] = params["segment_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/segments/{segmentId}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_trans_memory(self, trans_memory_uid, **kwargs) -> None:  # noqa: E501
        """Delete translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_trans_memory(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param bool purge:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def delete_trans_memory_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> None:  # noqa: E501
        """Delete translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_trans_memory_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param bool purge:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "purge"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_trans_memory" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `delete_trans_memory`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []
        if "purge" in params:
            query_params.append(("purge", params["purge"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_translation(
        self, trans_memory_uid, segment_id, lang, **kwargs
    ) -> None:  # noqa: E501
        """Delete segment of given language  # noqa: E501

        Not recommended for bulk removal of segments  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_translation(trans_memory_uid, segment_id, lang, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param str segment_id: (required)
        :param str lang: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_translation_with_http_info(
                trans_memory_uid, segment_id, lang, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_translation_with_http_info(
                trans_memory_uid, segment_id, lang, **kwargs
            )  # noqa: E501
            return data

    def delete_translation_with_http_info(
        self, trans_memory_uid, segment_id, lang, **kwargs
    ) -> None:  # noqa: E501
        """Delete segment of given language  # noqa: E501

        Not recommended for bulk removal of segments  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_translation_with_http_info(trans_memory_uid, segment_id, lang, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param str segment_id: (required)
        :param str lang: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "segment_id", "lang"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_translation" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `delete_translation`"
            )  # noqa: E501
        # verify the required parameter 'segment_id' is set
        if "segment_id" not in params or params["segment_id"] is None:
            raise ValueError(
                "Missing the required parameter `segment_id` when calling `delete_translation`"
            )  # noqa: E501
        # verify the required parameter 'lang' is set
        if "lang" not in params or params["lang"] is None:
            raise ValueError(
                "Missing the required parameter `lang` when calling `delete_translation`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501
        if "segment_id" in params:
            path_params["segmentId"] = params["segment_id"]  # noqa: E501
        if "lang" in params:
            path_params["lang"] = params["lang"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/segments/{segmentId}/lang/{lang}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def download_cleaned_tm(self, async_request_id, **kwargs) -> None:  # noqa: E501
        """Download cleaned TM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_cleaned_tm(async_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str async_request_id: Request ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.download_cleaned_tm_with_http_info(
                async_request_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.download_cleaned_tm_with_http_info(
                async_request_id, **kwargs
            )  # noqa: E501
            return data

    def download_cleaned_tm_with_http_info(
        self, async_request_id, **kwargs
    ) -> None:  # noqa: E501
        """Download cleaned TM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_cleaned_tm_with_http_info(async_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str async_request_id: Request ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["async_request_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_cleaned_tm" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'async_request_id' is set
        if "async_request_id" not in params or params["async_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `async_request_id` when calling `download_cleaned_tm`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "async_request_id" in params:
            path_params["asyncRequestId"] = params["async_request_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/downloadCleaned/{asyncRequestId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def download_search_result(self, async_request_id, **kwargs) -> None:  # noqa: E501
        """Download export  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_search_result(async_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str async_request_id: Request ID (required)
        :param str format:
        :param list[str] fields: Fields to include in exported XLSX
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.download_search_result_with_http_info(
                async_request_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.download_search_result_with_http_info(
                async_request_id, **kwargs
            )  # noqa: E501
            return data

    def download_search_result_with_http_info(
        self, async_request_id, **kwargs
    ) -> None:  # noqa: E501
        """Download export  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_search_result_with_http_info(async_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str async_request_id: Request ID (required)
        :param str format:
        :param list[str] fields: Fields to include in exported XLSX
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["async_request_id", "format", "fields"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_search_result" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'async_request_id' is set
        if "async_request_id" not in params or params["async_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `async_request_id` when calling `download_search_result`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "async_request_id" in params:
            path_params["asyncRequestId"] = params["async_request_id"]  # noqa: E501

        query_params = []
        if "format" in params:
            query_params.append(("format", params["format"]))  # noqa: E501
        if "fields" in params:
            query_params.append(("fields", params["fields"]))  # noqa: E501
            collection_formats["fields"] = "multi"  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/downloadExport/{asyncRequestId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def edit_trans_memory(
        self, trans_memory_uid, **kwargs
    ) -> TransMemoryDto:  # noqa: E501
        """Edit translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_trans_memory(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param TransMemoryEditDto body:
        :return: TransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.edit_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.edit_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def edit_trans_memory_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> TransMemoryDto:  # noqa: E501
        """Edit translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_trans_memory_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param TransMemoryEditDto body:
        :return: TransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_trans_memory" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `edit_trans_memory`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="TransMemoryDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def export_by_query_async(
        self, trans_memory_uid, **kwargs
    ) -> AsyncExportTMByQueryResponseDto:  # noqa: E501
        """Search translation memory  # noqa: E501

        Use [this API](#operation/downloadSearchResult) to download result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_by_query_async(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param ExportByQueryDto body:
        :return: AsyncExportTMByQueryResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.export_by_query_async_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.export_by_query_async_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def export_by_query_async_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> AsyncExportTMByQueryResponseDto:  # noqa: E501
        """Search translation memory  # noqa: E501

        Use [this API](#operation/downloadSearchResult) to download result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_by_query_async_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param ExportByQueryDto body:
        :return: AsyncExportTMByQueryResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_by_query_async" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `export_by_query_async`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/exportByQueryAsync",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AsyncExportTMByQueryResponseDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def export_cleaned_tms(self, **kwargs) -> AsyncRequestWrapperDto:  # noqa: E501
        """Extract cleaned translation memory  # noqa: E501

        Returns a ZIP file containing the cleaned translation memories in the specified outputFormat.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_cleaned_tms(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CleanedTransMemoriesDto body:
        :return: AsyncRequestWrapperDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.export_cleaned_tms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.export_cleaned_tms_with_http_info(**kwargs)  # noqa: E501
            return data

    def export_cleaned_tms_with_http_info(
        self, **kwargs
    ) -> AsyncRequestWrapperDto:  # noqa: E501
        """Extract cleaned translation memory  # noqa: E501

        Returns a ZIP file containing the cleaned translation memories in the specified outputFormat.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_cleaned_tms_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CleanedTransMemoriesDto body:
        :return: AsyncRequestWrapperDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_cleaned_tms" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/extractCleaned",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AsyncRequestWrapperDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def export_v2(
        self, trans_memory_uid, **kwargs
    ) -> AsyncExportTMResponseDto:  # noqa: E501
        """Export translation memory  # noqa: E501

        Use [this API](#operation/downloadSearchResult) to download result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_v2(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param ExportTMDto body:
        :return: AsyncExportTMResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.export_v2_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.export_v2_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def export_v2_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> AsyncExportTMResponseDto:  # noqa: E501
        """Export translation memory  # noqa: E501

        Use [this API](#operation/downloadSearchResult) to download result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_v2_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param ExportTMDto body:
        :return: AsyncExportTMResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `export_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/transMemories/{transMemoryUid}/export",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AsyncExportTMResponseDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_background_tasks1(
        self, trans_memory_uid, **kwargs
    ) -> BackgroundTasksTmDto:  # noqa: E501
        """Get last task information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_background_tasks1(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :return: BackgroundTasksTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_background_tasks1_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_background_tasks1_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def get_background_tasks1_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> BackgroundTasksTmDto:  # noqa: E501
        """Get last task information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_background_tasks1_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :return: BackgroundTasksTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_background_tasks1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `get_background_tasks1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/lastBackgroundTask",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="BackgroundTasksTmDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_metadata(
        self, trans_memory_uid, **kwargs
    ) -> MetadataResponse:  # noqa: E501
        """Get translation memory metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metadata(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param bool by_language:
        :return: MetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_metadata_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_metadata_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def get_metadata_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> MetadataResponse:  # noqa: E501
        """Get translation memory metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metadata_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param bool by_language:
        :return: MetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "by_language"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metadata" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `get_metadata`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []
        if "by_language" in params:
            query_params.append(("byLanguage", params["by_language"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/metadata",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="MetadataResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_project_template_trans_memories2(
        self, project_template_uid, **kwargs
    ) -> ProjectTemplateTransMemoryListDtoV3:  # noqa: E501
        """Get translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_template_trans_memories2(project_template_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_template_uid: (required)
        :param str target_lang: Filter project translation memories by target language
        :param str wf_step_uid: Filter project translation memories by workflow step
        :return: ProjectTemplateTransMemoryListDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_project_template_trans_memories2_with_http_info(
                project_template_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_project_template_trans_memories2_with_http_info(
                project_template_uid, **kwargs
            )  # noqa: E501
            return data

    def get_project_template_trans_memories2_with_http_info(
        self, project_template_uid, **kwargs
    ) -> ProjectTemplateTransMemoryListDtoV3:  # noqa: E501
        """Get translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_template_trans_memories2_with_http_info(project_template_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_template_uid: (required)
        :param str target_lang: Filter project translation memories by target language
        :param str wf_step_uid: Filter project translation memories by workflow step
        :return: ProjectTemplateTransMemoryListDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "project_template_uid",
            "target_lang",
            "wf_step_uid",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_template_trans_memories2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_template_uid' is set
        if (
            "project_template_uid" not in params
            or params["project_template_uid"] is None
        ):
            raise ValueError(
                "Missing the required parameter `project_template_uid` when calling `get_project_template_trans_memories2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_template_uid" in params:
            path_params["projectTemplateUid"] = params[
                "project_template_uid"
            ]  # noqa: E501

        query_params = []
        if "target_lang" in params:
            query_params.append(("targetLang", params["target_lang"]))  # noqa: E501
        if "wf_step_uid" in params:
            query_params.append(("wfStepUid", params["wf_step_uid"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projectTemplates/{projectTemplateUid}/transMemories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectTemplateTransMemoryListDtoV3",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_related_projects(
        self, trans_memory_uid, **kwargs
    ) -> PageDtoAbstractProjectDto:  # noqa: E501
        """List related projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_related_projects(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoAbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_related_projects_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_related_projects_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def get_related_projects_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> PageDtoAbstractProjectDto:  # noqa: E501
        """List related projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_related_projects_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoAbstractProjectDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "page_number", "page_size"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_related_projects" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `get_related_projects`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/relatedProjects",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoAbstractProjectDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_trans_memory(
        self, trans_memory_uid, **kwargs
    ) -> TransMemoryDto:  # noqa: E501
        """Get translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_trans_memory(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :return: TransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def get_trans_memory_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> TransMemoryDto:  # noqa: E501
        """Get translation memory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_trans_memory_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :return: TransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trans_memory" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `get_trans_memory`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="TransMemoryDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_translation_resources(
        self, project_uid, job_uid, **kwargs
    ) -> TranslationResourcesDto:  # noqa: E501
        """Get translation resources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_translation_resources(project_uid, job_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str job_uid: (required)
        :return: TranslationResourcesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_translation_resources_with_http_info(
                project_uid, job_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_translation_resources_with_http_info(
                project_uid, job_uid, **kwargs
            )  # noqa: E501
            return data

    def get_translation_resources_with_http_info(
        self, project_uid, job_uid, **kwargs
    ) -> TranslationResourcesDto:  # noqa: E501
        """Get translation resources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_translation_resources_with_http_info(project_uid, job_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str job_uid: (required)
        :return: TranslationResourcesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "job_uid"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_translation_resources" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `get_translation_resources`"
            )  # noqa: E501
        # verify the required parameter 'job_uid' is set
        if "job_uid" not in params or params["job_uid"] is None:
            raise ValueError(
                "Missing the required parameter `job_uid` when calling `get_translation_resources`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501
        if "job_uid" in params:
            path_params["jobUid"] = params["job_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/jobs/{jobUid}/translationResources",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="TranslationResourcesDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def import_trans_memory_v2(
        self, content_disposition, trans_memory_uid, **kwargs
    ) -> AsyncRequestWrapperV2Dto:  # noqa: E501
        """Import TMX  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_trans_memory_v2(content_disposition, trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_disposition: must match pattern `((inline|attachment); )?filename\\*=UTF-8''(.+)` (required)
        :param str trans_memory_uid: (required)
        :param InputStream body:
        :param int content_length:
        :param bool strict_lang_matching:
        :param bool strip_native_codes:
        :return: AsyncRequestWrapperV2Dto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.import_trans_memory_v2_with_http_info(
                content_disposition, trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.import_trans_memory_v2_with_http_info(
                content_disposition, trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def import_trans_memory_v2_with_http_info(
        self, content_disposition, trans_memory_uid, **kwargs
    ) -> AsyncRequestWrapperV2Dto:  # noqa: E501
        """Import TMX  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_trans_memory_v2_with_http_info(content_disposition, trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_disposition: must match pattern `((inline|attachment); )?filename\\*=UTF-8''(.+)` (required)
        :param str trans_memory_uid: (required)
        :param InputStream body:
        :param int content_length:
        :param bool strict_lang_matching:
        :param bool strip_native_codes:
        :return: AsyncRequestWrapperV2Dto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "content_disposition",
            "trans_memory_uid",
            "body",
            "content_length",
            "strict_lang_matching",
            "strip_native_codes",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_trans_memory_v2" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'content_disposition' is set
        if "content_disposition" not in params or params["content_disposition"] is None:
            raise ValueError(
                "Missing the required parameter `content_disposition` when calling `import_trans_memory_v2`"
            )  # noqa: E501
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `import_trans_memory_v2`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []
        if "strict_lang_matching" in params:
            query_params.append(
                ("strictLangMatching", params["strict_lang_matching"])
            )  # noqa: E501
        if "strip_native_codes" in params:
            query_params.append(
                ("stripNativeCodes", params["strip_native_codes"])
            )  # noqa: E501

        header_params = {}
        if "content_length" in params:
            header_params["Content-Length"] = params["content_length"]  # noqa: E501
        if "content_disposition" in params:
            header_params["Content-Disposition"] = params[
                "content_disposition"
            ]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/octet-stream", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v2/transMemories/{transMemoryUid}/import",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AsyncRequestWrapperV2Dto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def insert_to_trans_memory(self, trans_memory_uid, **kwargs) -> None:  # noqa: E501
        """Insert segment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insert_to_trans_memory(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param SegmentDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.insert_to_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.insert_to_trans_memory_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def insert_to_trans_memory_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> None:  # noqa: E501
        """Insert segment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insert_to_trans_memory_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param SegmentDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insert_to_trans_memory" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `insert_to_trans_memory`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/segments",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def list_trans_memories(self, **kwargs) -> PageDtoTransMemoryDto:  # noqa: E501
        """List translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_trans_memories(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name:
        :param str source_lang:
        :param str target_lang:
        :param str client_id:
        :param str domain_id:
        :param str sub_domain_id:
        :param str business_unit_id:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.list_trans_memories_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_trans_memories_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_trans_memories_with_http_info(
        self, **kwargs
    ) -> PageDtoTransMemoryDto:  # noqa: E501
        """List translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_trans_memories_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name:
        :param str source_lang:
        :param str target_lang:
        :param str client_id:
        :param str domain_id:
        :param str sub_domain_id:
        :param str business_unit_id:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "name",
            "source_lang",
            "target_lang",
            "client_id",
            "domain_id",
            "sub_domain_id",
            "business_unit_id",
            "page_number",
            "page_size",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_trans_memories" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "source_lang" in params:
            query_params.append(("sourceLang", params["source_lang"]))  # noqa: E501
        if "target_lang" in params:
            query_params.append(("targetLang", params["target_lang"]))  # noqa: E501
        if "client_id" in params:
            query_params.append(("clientId", params["client_id"]))  # noqa: E501
        if "domain_id" in params:
            query_params.append(("domainId", params["domain_id"]))  # noqa: E501
        if "sub_domain_id" in params:
            query_params.append(("subDomainId", params["sub_domain_id"]))  # noqa: E501
        if "business_unit_id" in params:
            query_params.append(
                ("businessUnitId", params["business_unit_id"])
            )  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoTransMemoryDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def relevant_trans_memories(
        self, project_template_uid, **kwargs
    ) -> PageDtoTransMemoryDto:  # noqa: E501
        """List project template relevant translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relevant_trans_memories(project_template_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_template_uid: (required)
        :param str name:
        :param str domain_name:
        :param str client_name:
        :param str sub_domain_name:
        :param list[str] target_langs:
        :param bool strict_lang_matching:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.relevant_trans_memories_with_http_info(
                project_template_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.relevant_trans_memories_with_http_info(
                project_template_uid, **kwargs
            )  # noqa: E501
            return data

    def relevant_trans_memories_with_http_info(
        self, project_template_uid, **kwargs
    ) -> PageDtoTransMemoryDto:  # noqa: E501
        """List project template relevant translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relevant_trans_memories_with_http_info(project_template_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_template_uid: (required)
        :param str name:
        :param str domain_name:
        :param str client_name:
        :param str sub_domain_name:
        :param list[str] target_langs:
        :param bool strict_lang_matching:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "project_template_uid",
            "name",
            "domain_name",
            "client_name",
            "sub_domain_name",
            "target_langs",
            "strict_lang_matching",
            "page_number",
            "page_size",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method relevant_trans_memories" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_template_uid' is set
        if (
            "project_template_uid" not in params
            or params["project_template_uid"] is None
        ):
            raise ValueError(
                "Missing the required parameter `project_template_uid` when calling `relevant_trans_memories`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_template_uid" in params:
            path_params["projectTemplateUid"] = params[
                "project_template_uid"
            ]  # noqa: E501

        query_params = []
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "domain_name" in params:
            query_params.append(("domainName", params["domain_name"]))  # noqa: E501
        if "client_name" in params:
            query_params.append(("clientName", params["client_name"]))  # noqa: E501
        if "sub_domain_name" in params:
            query_params.append(
                ("subDomainName", params["sub_domain_name"])
            )  # noqa: E501
        if "target_langs" in params:
            query_params.append(("targetLangs", params["target_langs"]))  # noqa: E501
            collection_formats["targetLangs"] = "multi"  # noqa: E501
        if "strict_lang_matching" in params:
            query_params.append(
                ("strictLangMatching", params["strict_lang_matching"])
            )  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projectTemplates/{projectTemplateUid}/transMemories/relevant",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoTransMemoryDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def relevant_trans_memories1(
        self, project_uid, **kwargs
    ) -> PageDtoTransMemoryDto:  # noqa: E501
        """List project relevant translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relevant_trans_memories1(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str name:
        :param str domain_name:
        :param str client_name:
        :param str sub_domain_name:
        :param list[str] target_langs:
        :param bool strict_lang_matching:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.relevant_trans_memories1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.relevant_trans_memories1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def relevant_trans_memories1_with_http_info(
        self, project_uid, **kwargs
    ) -> PageDtoTransMemoryDto:  # noqa: E501
        """List project relevant translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relevant_trans_memories1_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str name:
        :param str domain_name:
        :param str client_name:
        :param str sub_domain_name:
        :param list[str] target_langs:
        :param bool strict_lang_matching:
        :param int page_number: Page number, starting with 0, default 0
        :param int page_size: Page size, accepts values between 1 and 50, default 50
        :return: PageDtoTransMemoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "project_uid",
            "name",
            "domain_name",
            "client_name",
            "sub_domain_name",
            "target_langs",
            "strict_lang_matching",
            "page_number",
            "page_size",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method relevant_trans_memories1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `relevant_trans_memories1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "domain_name" in params:
            query_params.append(("domainName", params["domain_name"]))  # noqa: E501
        if "client_name" in params:
            query_params.append(("clientName", params["client_name"]))  # noqa: E501
        if "sub_domain_name" in params:
            query_params.append(
                ("subDomainName", params["sub_domain_name"])
            )  # noqa: E501
        if "target_langs" in params:
            query_params.append(("targetLangs", params["target_langs"]))  # noqa: E501
            collection_formats["targetLangs"] = "multi"  # noqa: E501
        if "strict_lang_matching" in params:
            query_params.append(
                ("strictLangMatching", params["strict_lang_matching"])
            )  # noqa: E501
        if "page_number" in params:
            query_params.append(("pageNumber", params["page_number"]))  # noqa: E501
        if "page_size" in params:
            query_params.append(("pageSize", params["page_size"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/transMemories/relevant",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PageDtoTransMemoryDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def search(
        self, trans_memory_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Search translation memory (sync)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param SearchRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.search_with_http_info(trans_memory_uid, **kwargs)  # noqa: E501
        else:
            (data) = self.search_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def search_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Search translation memory (sync)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param SearchRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method search" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `search`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/search",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SearchResponseListTmDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def search_by_job3(
        self, project_uid, job_uid, **kwargs
    ) -> SearchResponseListTmDtoV3:  # noqa: E501
        """Search job's translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_by_job3(project_uid, job_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str job_uid: (required)
        :param SearchTMByJobRequestDtoV3 body:
        :return: SearchResponseListTmDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.search_by_job3_with_http_info(
                project_uid, job_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.search_by_job3_with_http_info(
                project_uid, job_uid, **kwargs
            )  # noqa: E501
            return data

    def search_by_job3_with_http_info(
        self, project_uid, job_uid, **kwargs
    ) -> SearchResponseListTmDtoV3:  # noqa: E501
        """Search job's translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_by_job3_with_http_info(project_uid, job_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str job_uid: (required)
        :param SearchTMByJobRequestDtoV3 body:
        :return: SearchResponseListTmDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "job_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_by_job3" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `search_by_job3`"
            )  # noqa: E501
        # verify the required parameter 'job_uid' is set
        if "job_uid" not in params or params["job_uid"] is None:
            raise ValueError(
                "Missing the required parameter `job_uid` when calling `search_by_job3`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501
        if "job_uid" in params:
            path_params["jobUid"] = params["job_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["*/*"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projects/{projectUid}/jobs/{jobUid}/transMemories/search",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SearchResponseListTmDtoV3",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def search_segment1(
        self, project_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Search translation memory for segment in the project  # noqa: E501

        Returns at most <i>maxSegments</i>             records with <i>score >= scoreThreshold</i> and at most <i>maxSubsegments</i> records which are subsegment,             i.e. the source text is substring of the query text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_segment1(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SearchTMRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.search_segment1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.search_segment1_with_http_info(
                project_uid, **kwargs
            )  # noqa: E501
            return data

    def search_segment1_with_http_info(
        self, project_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Search translation memory for segment in the project  # noqa: E501

        Returns at most <i>maxSegments</i>             records with <i>score >= scoreThreshold</i> and at most <i>maxSubsegments</i> records which are subsegment,             i.e. the source text is substring of the query text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_segment1_with_http_info(project_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param SearchTMRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_segment1" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `search_segment1`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/transMemories/searchSegmentInProject",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SearchResponseListTmDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def search_segment_by_job(
        self, project_uid, job_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Search translation memory for segment by job  # noqa: E501

        Returns at most <i>maxSegments</i>             records with <i>score >= scoreThreshold</i> and at most <i>maxSubsegments</i> records which are subsegment,             i.e. the source text is substring of the query text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_segment_by_job(project_uid, job_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str job_uid: (required)
        :param SearchTMByJobRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.search_segment_by_job_with_http_info(
                project_uid, job_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.search_segment_by_job_with_http_info(
                project_uid, job_uid, **kwargs
            )  # noqa: E501
            return data

    def search_segment_by_job_with_http_info(
        self, project_uid, job_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Search translation memory for segment by job  # noqa: E501

        Returns at most <i>maxSegments</i>             records with <i>score >= scoreThreshold</i> and at most <i>maxSubsegments</i> records which are subsegment,             i.e. the source text is substring of the query text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_segment_by_job_with_http_info(project_uid, job_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str job_uid: (required)
        :param SearchTMByJobRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "job_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_segment_by_job" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `search_segment_by_job`"
            )  # noqa: E501
        # verify the required parameter 'job_uid' is set
        if "job_uid" not in params or params["job_uid"] is None:
            raise ValueError(
                "Missing the required parameter `job_uid` when calling `search_segment_by_job`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501
        if "job_uid" in params:
            path_params["jobUid"] = params["job_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/projects/{projectUid}/jobs/{jobUid}/transMemories/searchSegment",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SearchResponseListTmDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def update_translation(
        self, trans_memory_uid, segment_id, **kwargs
    ) -> None:  # noqa: E501
        """Edit segment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_translation(trans_memory_uid, segment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param str segment_id: (required)
        :param TranslationDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.update_translation_with_http_info(
                trans_memory_uid, segment_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.update_translation_with_http_info(
                trans_memory_uid, segment_id, **kwargs
            )  # noqa: E501
            return data

    def update_translation_with_http_info(
        self, trans_memory_uid, segment_id, **kwargs
    ) -> None:  # noqa: E501
        """Edit segment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_translation_with_http_info(trans_memory_uid, segment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param str segment_id: (required)
        :param TranslationDto body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "segment_id", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_translation" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `update_translation`"
            )  # noqa: E501
        # verify the required parameter 'segment_id' is set
        if "segment_id" not in params or params["segment_id"] is None:
            raise ValueError(
                "Missing the required parameter `segment_id` when calling `update_translation`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501
        if "segment_id" in params:
            path_params["segmentId"] = params["segment_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/segments/{segmentId}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def wild_card_search_by_job3(
        self, project_uid, job_uid, **kwargs
    ) -> SearchResponseListTmDtoV3:  # noqa: E501
        """Wildcard search job's translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.wild_card_search_by_job3(project_uid, job_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str job_uid: (required)
        :param WildCardSearchByJobRequestDtoV3 body:
        :return: SearchResponseListTmDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.wild_card_search_by_job3_with_http_info(
                project_uid, job_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.wild_card_search_by_job3_with_http_info(
                project_uid, job_uid, **kwargs
            )  # noqa: E501
            return data

    def wild_card_search_by_job3_with_http_info(
        self, project_uid, job_uid, **kwargs
    ) -> SearchResponseListTmDtoV3:  # noqa: E501
        """Wildcard search job's translation memories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.wild_card_search_by_job3_with_http_info(project_uid, job_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_uid: (required)
        :param str job_uid: (required)
        :param WildCardSearchByJobRequestDtoV3 body:
        :return: SearchResponseListTmDtoV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project_uid", "job_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method wild_card_search_by_job3" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'project_uid' is set
        if "project_uid" not in params or params["project_uid"] is None:
            raise ValueError(
                "Missing the required parameter `project_uid` when calling `wild_card_search_by_job3`"
            )  # noqa: E501
        # verify the required parameter 'job_uid' is set
        if "job_uid" not in params or params["job_uid"] is None:
            raise ValueError(
                "Missing the required parameter `job_uid` when calling `wild_card_search_by_job3`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "project_uid" in params:
            path_params["projectUid"] = params["project_uid"]  # noqa: E501
        if "job_uid" in params:
            path_params["jobUid"] = params["job_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v3/projects/{projectUid}/jobs/{jobUid}/transMemories/wildCardSearch",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SearchResponseListTmDtoV3",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def wildcard_search(
        self, trans_memory_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Wildcard search  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.wildcard_search(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param WildCardSearchRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.wildcard_search_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.wildcard_search_with_http_info(
                trans_memory_uid, **kwargs
            )  # noqa: E501
            return data

    def wildcard_search_with_http_info(
        self, trans_memory_uid, **kwargs
    ) -> SearchResponseListTmDto:  # noqa: E501
        """Wildcard search  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.wildcard_search_with_http_info(trans_memory_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str trans_memory_uid: (required)
        :param WildCardSearchRequestDto body:
        :return: SearchResponseListTmDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["trans_memory_uid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method wildcard_search" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'trans_memory_uid' is set
        if "trans_memory_uid" not in params or params["trans_memory_uid"] is None:
            raise ValueError(
                "Missing the required parameter `trans_memory_uid` when calling `wildcard_search`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "trans_memory_uid" in params:
            path_params["transMemoryUid"] = params["trans_memory_uid"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api2/v1/transMemories/{transMemoryUid}/wildCardSearch",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SearchResponseListTmDto",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
